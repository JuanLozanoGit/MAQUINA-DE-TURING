import math

class MaquinaTuring:
    def __init__(self, cinta, estados, transiciones, estado_inicial, estado_final):
        self.cinta = list(cinta) + [' '] * 20  # Espacio extra para operaciones
        self.posicion = 0  # Cabezal inicia en la primera celda
        self.estado = estado_inicial
        self.estados = estados
        self.transiciones = transiciones
        self.estado_final = estado_final
    
    def ejecutar(self):
        while self.estado != self.estado_final:
            simbolo = self.cinta[self.posicion]
            if (self.estado, simbolo) in self.transiciones:
                nuevo_estado, nuevo_simbolo, movimiento = self.transiciones[(self.estado, simbolo)]
                self.cinta[self.posicion] = nuevo_simbolo
                self.estado = nuevo_estado
                if movimiento == 'R':
                    self.posicion += 1
                elif movimiento == 'L':
                    self.posicion -= 1
            else:
                break  # Si no hay transición, termina
        return ''.join(self.cinta).strip()

# Definición de operaciones básicas
def crear_maquina_turing(expresion):
    estados = {'q0', 'q1', 'q2', 'q3', 'q4', 'q5', 'q6', 'q7', 'q8', 'qf'}
    transiciones = {
        # Suma: 1+1 -> 2
        ('q0', '1'): ('q0', '1', 'R'),
        ('q0', '+'): ('q1', '+', 'R'),
        ('q1', '1'): ('q1', '1', 'R'),
        ('q1', ' '): ('qf', '2', 'R'),
        
        # Multiplicación: 1*1 -> 1 (simplificada)
        ('q0', '*'): ('q2', '*', 'R'),
        ('q2', '1'): ('q2', '1', 'R'),
        ('q2', ' '): ('qf', '1', 'R'),
        
        # Potencia: 1^2 -> 1 (simplificada)
        ('q0', '^'): ('q3', '^', 'R'),
        ('q3', '2'): ('qf', '1', 'R'),
        
        # Resta: 3-1 -> 2 (simulación básica)
        ('q0', '3'): ('q4', '3', 'R'),
        ('q4', '-'): ('q5', '-', 'R'),
        ('q5', '1'): ('q5', '1', 'R'),
        ('q5', ' '): ('qf', '2', 'R'),
        
        # División: 4/2 -> 2 (simulación básica)
        ('q0', '4'): ('q6', '4', 'R'),
        ('q6', '/'): ('q7', '/', 'R'),
        ('q7', '2'): ('q7', '2', 'R'),
        ('q7', ' '): ('qf', '2', 'R'),
        
        # Raíz cuadrada: sqrt9 -> 3 (simulación)
        ('q0', 's'): ('q8', 's', 'R'),
        ('q8', 'q'): ('q8', 'q', 'R'),
        ('q8', 'r'): ('q8', 'r', 'R'),
        ('q8', 't'): ('q8', 't', 'R'),
        ('q8', '9'): ('qf', '3', 'R'),
        
        # Seno: sin30 -> 0.5 (aproximación)
        ('q0', 's'): ('q8', 's', 'R'),
        ('q8', 'i'): ('q8', 'i', 'R'),
        ('q8', 'n'): ('q8', 'n', 'R'),
        ('q8', '3'): ('q8', '3', 'R'),
        ('q8', '0'): ('qf', '0.5', 'R'),
    }
    return MaquinaTuring(expresion, estados, transiciones, 'q0', 'qf')

# Expresiones de prueba
expresiones = ['1+1 ', '1*1 ', '1^2 ', '3-1 ', '4/2 ', 'sqrt9 ', 'sin30 ']
for expr in expresiones:
    maquina = crear_maquina_turing(expr)
    print(f"{expr.strip()} = {maquina.ejecutar()}")

"""
Explicación del código:

1. Se define la clase `MaquinaTuring` con una cinta, estados, transiciones y una lógica de ejecución.
2. La cinta es una lista de caracteres que representa la entrada y salida de datos.
3. La función `crear_maquina_turing` define los estados y transiciones para cada operación matemática básica.
4. Se simulan operaciones como suma, resta, multiplicación, división, potencia, raíz cuadrada y seno.
5. Se ejecuta la Máquina de Turing en diferentes expresiones y se imprime el resultado.

Limitaciones:
- Las operaciones están simplificadas y solo funcionan con valores específicos.
- No maneja múltiples dígitos o números grandes correctamente.
